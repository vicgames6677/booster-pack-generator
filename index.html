<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Booster Pack Manifest Generator</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }
    #walletAddress {
      margin-top: 10px;
      font-weight: bold;
    }
    #packGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 20px;
    }
    .pack {
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
    .pack select {
      width: 100%;
      margin-bottom: 5px;
      font-weight: bold;
      color: #333;
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #aaa;
      cursor: pointer;
      appearance: none;
      background-color: #f8d7da; /* Red background for unassigned */
    }
    .pack select.assigned {
      background-color: #d4edda; /* Green for assigned */
      border-color: #28a745;
      color: #155724;
    }
    label, input, button {
      margin: 5px 10px 5px 0;
    }
    #collectionsList {
      margin-top: 10px;
      margin-bottom: 20px;
      max-width: 600px;
    }
    .collection-row {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
    }
    .collection-row input {
      margin-right: 8px;
      padding: 4px;
      flex: 1;
    }
    .collection-row input.alias {
      max-width: 60px;
      text-transform: uppercase;
      font-weight: bold;
    }
    .collection-row button {
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-weight: bold;
    }
    .collection-row button:hover {
      background: #bd2130;
    }
    #loadInventoryStatus {
      margin-bottom: 10px;
      font-weight: bold;
      color: #007bff;
    }
    #exportManifest:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <h1>Booster Pack Manifest Generator</h1>
  <button id="connectWallet">Connect Wallet</button>
  <div id="walletAddress">Not connected</div>

  <h3>Allowed Collections</h3>
  <div id="collectionsList"></div>
  <button id="addCollectionBtn">Add Collection</button>

  <button id="loadInventoryBtn" style="margin-top:10px;">Load Inventory</button>
  <div id="loadInventoryStatus"></div>

  <div style="margin-top: 20px;">
    <label for="cardsPerPack">Cards per Pack:</label>
    <input type="number" id="cardsPerPack" value="5" min="1" max="50" />

    <label for="packsPerManifest">Number of Packs:</label>
    <input type="number" id="packsPerManifest" value="10" min="1" max="100" />

    <button id="generateGridBtn">Generate Pack Grid</button>
  </div>

  <div id="packGrid"></div>
  <button id="exportManifest" style="margin-top: 20px;" disabled>Export Manifest</button>

  <script>
    let provider, signer, connectedAddress = null;
    let allowedCollections = [];
    let walletInventory = {};
    let currentSelections = [];

    document.getElementById('connectWallet').addEventListener('click', async () => {
      if (window.ethereum) {
        try {
          await window.ethereum.request({ method: 'eth_requestAccounts' });
          provider = new ethers.providers.Web3Provider(window.ethereum);
          signer = provider.getSigner();
          connectedAddress = await signer.getAddress();
          document.getElementById('walletAddress').innerText = `Connected: ${connectedAddress}`;
        } catch (err) {
          alert('Wallet connection failed.');
          console.error(err);
        }
      } else {
        alert('MetaMask not detected.');
      }
    });

    function addCollectionRow(address = '', alias = '') {
      const container = document.getElementById('collectionsList');
      const row = document.createElement('div');
      row.className = 'collection-row';

      const addrInput = document.createElement('input');
      addrInput.type = 'text';
      addrInput.placeholder = 'Collection Address';
      addrInput.value = address;
      addrInput.className = 'address';

      const aliasInput = document.createElement('input');
      aliasInput.type = 'text';
      aliasInput.placeholder = 'Alias';
      aliasInput.value = alias.toUpperCase();
      aliasInput.className = 'alias';

      const removeBtn = document.createElement('button');
      removeBtn.textContent = 'X';
      removeBtn.addEventListener('click', () => row.remove());

      row.appendChild(addrInput);
      row.appendChild(aliasInput);
      row.appendChild(removeBtn);
      container.appendChild(row);
    }

    document.getElementById('addCollectionBtn').addEventListener('click', () => {
      addCollectionRow();
    });

    async function loadInventory() {
      document.getElementById('loadInventoryStatus').textContent = 'Loading inventory...';
      const rows = document.querySelectorAll('.collection-row');
      allowedCollections = [];
      walletInventory = {};

      for (const row of rows) {
        const addr = row.querySelector('.address').value.trim();
        const alias = row.querySelector('.alias').value.trim().toUpperCase();
        if (ethers.utils.isAddress(addr) && alias) {
          allowedCollections.push({ address: addr, alias });
        }
      }

      for (const { address, alias } of allowedCollections) {
        const contract = new ethers.Contract(address, [
          "function balanceOf(address, uint256) view returns (uint256)"
        ], provider);

        for (let tokenId = 0; tokenId < 200; tokenId++) {
          try {
            const balance = await contract.balanceOf(connectedAddress, tokenId);
            if (balance.gt(0)) {
              const key = `${alias}/${tokenId}`;
              walletInventory[key] = balance.toNumber();
            }
          } catch {}
        }
      }

      document.getElementById('loadInventoryStatus').textContent = 'âœ… Inventory loaded';
    }

    document.getElementById('loadInventoryBtn').addEventListener('click', async () => {
      await loadInventory();
    });

    document.getElementById('generateGridBtn').addEventListener('click', () => {
      if (Object.keys(walletInventory).length === 0) {
        alert("Please load inventory before generating the grid.");
        return;
      }

      const cardsPerPack = parseInt(document.getElementById('cardsPerPack').value);
      const numPacks = parseInt(document.getElementById('packsPerManifest').value);
      const gridContainer = document.getElementById('packGrid');
      currentSelections = [];
      gridContainer.innerHTML = '';

      for (let p = 0; p < numPacks; p++) {
        const pack = document.createElement('div');
        pack.className = 'pack';
        const packSelection = [];

        for (let c = 0; c < cardsPerPack; c++) {
          const select = document.createElement('select');
          const option = document.createElement('option');
          option.text = 'Select a token';
          select.appendChild(option);

          for (const key in walletInventory) {
            if (walletInventory[key] > 0) {
              const opt = document.createElement('option');
              opt.value = key;
              opt.text = key;
              select.appendChild(opt);
            }
          }

          select.addEventListener('change', () => {
            const prev = select.getAttribute('data-prev');
            if (prev && walletInventory[prev] !== undefined) {
              walletInventory[prev]++;
            }

            const selected = select.value;
            if (walletInventory[selected] > 0) {
              walletInventory[selected]--;
              select.classList.add('assigned');
              select.setAttribute('data-prev', selected);
              checkExportReadiness();
            } else {
              alert("This token is no longer available.");
              select.value = '';
            }

            // Refresh all other dropdowns
            document.querySelectorAll('select').forEach(drop => {
              if (!drop.classList.contains('assigned')) {
                [...drop.options].forEach(opt => {
                  if (walletInventory[opt.value] === 0 && opt.value !== '') {
                    opt.disabled = true;
                  }
                });
              }
            });
          });

          pack.appendChild(select);
          packSelection.push(select);
        }

        currentSelections.push(packSelection);
        gridContainer.appendChild(pack);
      }
    });

    function checkExportReadiness() {
      for (const pack of currentSelections) {
        for (const sel of pack) {
          if (!sel.classList.contains('assigned')) {
            document.getElementById('exportManifest').disabled = true;
            return;
          }
        }
      }
      document.getElementById('exportManifest').disabled = false;
    }

    document.getElementById('exportManifest').addEventListener('click', () => {
      const manifest = currentSelections.map(pack =>
        pack.map(sel => sel.value)
      );
      const blob = new Blob([JSON.stringify(manifest, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'manifest.json';
      a.click();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
